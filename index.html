<!DOCTYPE html>
<html>
<head>
  <title>Routing Algorithm Race - Disaster Mode</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: auto;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    }

    .main-container {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      width: 100%;
    }

    .header-section {
      flex: 0 0 auto;
      padding: 15px 20px;
      background: white;
      border-bottom: 1px solid #e5e7eb;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      position: sticky;
      top: 0;
      z-index: 1000;
    }

    .content-area {
      flex: 1 1 auto;
      display: flex;
      min-height: 600px;
      height: calc(100vh - 200px);
    }

    .map-panel {
      flex: 1 1 70%;
      min-width: 0;
      position: relative;
      height: 100%;
    }

    #map {
      height: 100%;
      width: 100%;
    }

    .results-panel {
      flex: 0 0 30%;
      min-width: 0;
      display: flex;
      flex-direction: column;
      background: #f8fafc;
      border-left: 1px solid #e5e7eb;
      height: 100%;
    }

    .results-header {
      flex: 0 0 auto;
      padding: 15px 20px;
      background: #1e40af;
      color: white;
      border-bottom: 1px solid #e5e7eb;
    }

    .results-content {
      flex: 1 1 auto;
      overflow-y: auto;
      padding: 20px;
      height: 100%;
    }

    .controls-section {
      background: white;
      padding: 15px 20px;
      border-bottom: 1px solid #e5e7eb;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      align-items: center;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .control-label {
      font-size: 0.875rem;
      font-weight: 600;
      color: #374151;
    }

    .control-input {
      padding: 8px 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 0.875rem;
    }

    .control-input:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .disaster-controls {
      background: white;
      padding: 15px 20px;
      border-bottom: 1px solid #e5e7eb;
    }

    .disaster-buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .disaster-btn {
      padding: 10px 16px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 0.875rem;
      transition: all 0.2s;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .disaster-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }

    .disaster-btn.flood {
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      color: white;
    }

    .disaster-btn.fire {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
    }

    .disaster-btn.earthquake {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      color: white;
    }

    .disaster-btn.reset {
      background: linear-gradient(135deg, #6b7280, #4b5563);
      color: white;
    }

    .blocking-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      background: #f3f4f6;
      border-radius: 6px;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #dc2626;
      transition: .4s;
      border-radius: 24px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: #10b981;
    }

    input:checked + .toggle-slider:before {
      transform: translateX(20px);
    }

    .action-buttons {
      display: flex;
      gap: 10px;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.875rem;
    }

    .btn-primary {
      background: #10b981;
      color: white;
    }

    .btn-primary:hover {
      background: #059669;
      transform: translateY(-1px);
    }

    .btn-secondary {
      background: #ef4444;
      color: white;
    }

    .btn-secondary:hover {
      background: #dc2626;
      transform: translateY(-1px);
    }

    #eda-section {
      border-bottom: 1px solid #e5e7eb;
    }

    .eda-stat-card {
      background: linear-gradient(135deg, #f8fafc, #e2e8f0);
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      border-left: 4px solid #8b5cf6;
    }

    .eda-stat-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: #1e40af;
    }

    .eda-stat-label {
      font-size: 0.875rem;
      color: #64748b;
      margin-top: 5px;
    }

    .eda-viz-card {
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .eda-viz-title {
      font-size: 1rem;
      font-weight: 600;
      color: #374151;
      margin-bottom: 10px;
      text-align: center;
    }

    .eda-viz-image {
      width: 100%;
      height: auto;
      border-radius: 4px;
    }

    .hidden {
      display: none !important;
    }

    .map-controls {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .legend {
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      max-width: 250px;
    }

    .legend h4 {
      margin: 0 0 10px 0;
      font-size: 0.875rem;
      font-weight: 600;
      color: #374151;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
      cursor: pointer;
      transition: background-color 0.2s;
      border-radius: 4px;
      padding: 4px 8px;
    }

    .legend-item:hover {
      background-color: #f3f4f6;
    }

    .legend-item.active {
      background-color: #e0e7ff;
    }

    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      flex-shrink: 0;
    }

    .disaster-info {
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      border-left: 4px solid;
      margin-top: 10px;
    }

    .disaster-info.flood {
      border-color: #3b82f6;
    }

    .disaster-info.fire {
      border-color: #ef4444;
    }

    .disaster-info.earthquake {
      border-color: #f59e0b;
    }

    .results-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.875rem;
    }

    .results-table th {
      background: #374151;
      color: white;
      padding: 10px;
      text-align: left;
      font-weight: 600;
    }

    .results-table td {
      padding: 10px;
      border-bottom: 1px solid #e5e7eb;
    }

    .results-table tr:hover {
      background-color: #f9fafb;
    }

    .race-algorithm {
      background: white;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .race-progress {
      height: 20px;
      background-color: #e5e7eb;
      border-radius: 10px;
      margin-top: 8px;
      overflow: hidden;
    }

    .race-progress-bar {
      height: 100%;
      border-radius: 10px;
      transition: width 0.3s ease;
    }

    @media (max-width: 1024px) {
      .content-area {
        flex-direction: column;
        height: auto;
      }
      
      .map-panel {
        flex: 1 1 500px;
        min-height: 500px;
      }
      
      .results-panel {
        flex: 1 1 400px;
        min-height: 400px;
      }
    }

    @media (max-width: 768px) {
      .controls-grid {
        grid-template-columns: 1fr;
      }
      
      .disaster-buttons {
        flex-direction: column;
      }
      
      .action-buttons {
        flex-direction: column;
      }
      
      .content-area {
        flex-direction: column;
        height: auto;
      }
      
      .map-panel {
        min-height: 400px;
      }
      
      .results-panel {
        min-height: 300px;
      }
    }

    .results-content::-webkit-scrollbar {
      width: 6px;
    }

    .results-content::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    .results-content::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 3px;
    }

    .results-content::-webkit-scrollbar-thumb:hover {
      background: #a8a8a8;
    }

    .road-line {
      z-index: 5;
    }
    .path-line {
      z-index: 15;
    }
    .start-icon, .end-icon {
      z-index: 100;
    }
    .race-marker {
      z-index: 200;
      filter: drop-shadow(0 0 5px rgba(0,0,0,0.7));
    }
  </style>
</head>
<body class="overflow-auto">
  <div class="main-container">
    <div class="header-section">
      <h1 class="text-2xl font-bold text-gray-800">Pathfinding Algorithm Race - Disaster Mode</h1>
    </div>

    <div class="controls-section">
      <div class="controls-grid">
        <div class="control-group">
          <label for="start_node" class="control-label">Start Node</label>
          <input type="text" id="start_node" placeholder="(14.179543, 121.241683)" class="control-input" />
        </div>
        
        <div class="control-group">
          <label for="end_node" class="control-label">End Node</label>
          <input type="text" id="end_node" placeholder="(14.153306, 121.248118)" class="control-input" />
        </div>

        <div class="blocking-controls">
          <span class="control-label">Block Mode:</span>
          <label class="toggle-switch">
            <input type="checkbox" id="blocking-toggle" checked>
            <span class="toggle-slider"></span>
          </label>
          <span class="text-sm text-gray-600">
            (<span id="blocked-count">0</span>/10)
          </span>
        </div>

        <div class="action-buttons">
          <button onclick="startRace()" class="btn btn-primary">
            Start Race
          </button>
          <button onclick="resetAll()" class="btn btn-secondary">
            Reset All
          </button>
          <button onclick="showEDA()" class="btn" style="background: #8b5cf6; color: white;">
            üìä Show Data Analysis
          </button>
          <button onclick="showAlgorithmMetrics()" class="btn" style="background: #dc2626; color: white;">
              üìà Algorithm Metrics
          </button>
        </div>
      </div>
    </div>

    <div id="algorithm-metrics-section" class="hidden">
      <div class="controls-section">
        <div class="flex justify-between items-center">
          <h3 class="font-semibold text-lg">Algorithm Performance Metrics</h3>
          <button onclick="hideAlgorithmMetrics()" class="btn btn-secondary">
            Close Metrics
          </button>
        </div>
      </div>

      <div class="bg-white p-6">
        <div id="metrics-statistics" class="mb-6 grid grid-cols-1 md:grid-cols-3 gap-4">
        </div>

        <div id="metrics-visualizations" class="grid grid-cols-1 gap-6">
        </div>

        <div id="metrics-loading" class="text-center py-10">
          <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-red-500 mx-auto mb-4"></div>
          <p class="text-gray-600">Calculating algorithm performance metrics...</p>
        </div>

        <div id="metrics-error" class="hidden text-center py-10">
          <div class="text-red-500 text-4xl mb-4">‚ùå</div>
          <p class="text-red-600 font-semibold">Error loading algorithm metrics</p>
          <p class="text-gray-600 mt-2" id="metrics-error-message"></p>
          <button onclick="loadAlgorithmMetrics()" class="btn btn-primary mt-4">
            Try Again
          </button>
        </div>
      </div>
    </div>

    <div id="eda-section" class="hidden">
      <div class="controls-section">
        <div class="flex justify-between items-center">
          <h3 class="font-semibold text-lg">Road Network Data Analysis</h3>
          <button onclick="hideEDA()" class="btn btn-secondary">
            Close Analysis
          </button>
        </div>
      </div>

      <div class="bg-white p-6">
        <div id="eda-statistics" class="mb-6 grid grid-cols-2 md:grid-cols-4 gap-4">
        </div>

        <div id="eda-visualizations" class="grid grid-cols-1 md:grid-cols-2 gap-6">
        </div>

        <div id="eda-loading" class="text-center py-10">
          <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-purple-500 mx-auto mb-4"></div>
          <p class="text-gray-600">Generating data analysis visualizations...</p>
        </div>

        <div id="eda-error" class="hidden text-center py-10">
          <div class="text-red-500 text-4xl mb-4">‚ùå</div>
          <p class="text-red-600 font-semibold">Error loading data analysis</p>
          <p class="text-gray-600 mt-2" id="eda-error-message"></p>
          <button onclick="loadEDA()" class="btn btn-primary mt-4">
            Try Again
          </button>
        </div>
      </div>
    </div>

    <div class="disaster-controls">
      <h3 class="font-semibold text-lg mb-3">Disaster Simulation</h3>
      <div class="disaster-buttons">
        <button class="disaster-btn flood" onclick="simulateDisaster('flood')">
          üåä Simulate Flood
        </button>
        <button class="disaster-btn fire" onclick="simulateDisaster('fire')">
          üî• Simulate Fire (2-3 edges max)
        </button>
        <button class="disaster-btn earthquake" onclick="simulateDisaster('earthquake')">
          üåç Simulate Earthquake
        </button>
        <button class="disaster-btn reset" onclick="clearDisaster()">
          üóëÔ∏è Clear Disaster
        </button>
      </div>
      
      <div id="fire-origin-container" class="hidden mt-3">
        <div class="control-group" style="max-width: 300px;">
          <label for="fire_origin" class="control-label">Fire Origin Node</label>
          <input type="text" id="fire_origin" placeholder="(14.153439, 121.248028)" class="control-input" />
        </div>
        <div class="text-xs text-orange-600 mt-2">
          ‚ö†Ô∏è Fire disaster will be limited to 2-3 blocked edges. End nodes remain reachable with 1-2 minute delays.
        </div>
      </div>
      
      <div id="disaster-info" class="hidden"></div>
    </div>

    <div class="content-area">
      <div class="map-panel">
        <div id="map"></div>
        
        <div class="map-controls">
          <div class="legend">
            <h4>Pathfinding Algorithms</h4>
            <div id="algorithm-legend">
            </div>
          </div>
          
          <div class="legend">
            <h4>Disaster Effects</h4>
            <div class="legend-item">
              <div class="legend-color" style="background-color: #3b82f6;"></div>
              <span class="text-sm">Flood (30 edges blocked)</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background-color: #ef4444;"></div>
              <span class="text-sm">Fire Blocked (2-3 max)</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background-color: #f59e0b;"></div>
              <span class="text-sm">Earthquake (40 edges blocked)</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background-color: #dc2626;"></div>
              <span class="text-sm">Completely Blocked</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background-color: #10b981;"></div>
              <span class="text-sm">End Node Access (1-2 min delay)</span>
            </div>
          </div>
        </div>
      </div>

      <div class="results-panel">
        <div class="results-header">
          <div class="flex justify-between items-center">
            <span class="font-medium">Race Status:</span>
            <span id="race-state" class="px-3 py-1 bg-white text-gray-800 rounded-full text-sm font-medium">Not Started</span>
          </div>
        </div>
        <div class="results-content" id="results">
          <div class="text-center text-gray-500 my-10">
            <p class="mb-4">Set your start and end nodes, configure disasters, and click "Start Race" to begin</p>
            <div class="text-sm text-gray-400">
              <p>‚Ä¢ Use Block Mode to manually block roads</p>
              <p>‚Ä¢ Fire disasters are limited to 2-3 blocked edges for containment</p>
              <p>‚Ä¢ End nodes remain reachable with 1-2 minute delays in fire disasters</p>
              <p>‚Ä¢ Compare performance across different pathfinding algorithms</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <script>
  let map;
  let startMarker, endMarker;
  let pathLayers = {};
  let roadLayers = [];
  let allRoads = [];
  let blockedEdges = new Set();
  let disasterEdges = new Set();
  const MAX_BLOCKED = 10;
  let isBlockingMode = true;
  let raceMarkers = {};
  let raceInterval;
  let raceState = 'not_started';
  
  let allAlgorithmResults = {};
  let currentSelectedAlgorithm = null;
  
  let raceData = {};
  
  let currentDisaster = null;
  
  const algorithmColors = {
    'Dijkstra': '#2563eb',
    'A*': '#9333ea',
    'Greedy BFS': '#16a34a',
    'Ant Colony': '#92400e'
  };

  const disasterColors = {
    'flood': '#3b82f6',
    'fire': '#ef4444',
    'earthquake': '#f59e0b',
    'end_node_access': '#10b981'
  };

  function initMap() {
    map = L.map('map').setView([14.166, 121.245], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    document.getElementById('blocking-toggle').addEventListener('change', function(e) {
      isBlockingMode = e.target.checked;
    });

    loadRoadData();
  }

  function initAlgorithmLegend() {
    const legendContainer = document.getElementById('algorithm-legend');
    
    for (const algo in algorithmColors) {
      const legendItem = document.createElement('div');
      legendItem.className = 'legend-item';
      legendItem.onclick = () => toggleAlgorithm(algo);
      legendItem.id = `legend-${algo}`;
      
      legendItem.innerHTML = `
        <div class="legend-color" style="background-color: ${algorithmColors[algo]}"></div>
        <span class="text-sm flex-1">${algo} Path</span>
      `;
      
      legendContainer.appendChild(legendItem);
    }
  }

  function showEDA() {
    document.getElementById('eda-section').classList.remove('hidden');
    loadEDA();
  }

  function hideEDA() {
    document.getElementById('eda-section').classList.add('hidden');
  }

  async function loadEDA() {
    const loadingElement = document.getElementById('eda-loading');
    const errorElement = document.getElementById('eda-error');
    const visualizationsElement = document.getElementById('eda-visualizations');
    const statisticsElement = document.getElementById('eda-statistics');
    
    loadingElement.classList.remove('hidden');
    errorElement.classList.add('hidden');
    visualizationsElement.innerHTML = '';
    statisticsElement.innerHTML = '';

    try {
      const response = await fetch('/get_eda_visualizations');
      const data = await response.json();

      if (!data.success) {
        throw new Error(data.error || 'Failed to load EDA data');
      }

      loadingElement.classList.add('hidden');

      if (data.statistics) {
        displayStatistics(data.statistics, statisticsElement);
      }

      if (data.visualizations) {
        displayVisualizations(data.visualizations, visualizationsElement);
      }

    } catch (error) {
      console.error('Error loading EDA:', error);
      loadingElement.classList.add('hidden');
      errorElement.classList.remove('hidden');
      document.getElementById('eda-error-message').textContent = error.message;
    }
  }

  function displayStatistics(stats, container) {
    let html = '';

    if (stats.total_roads) {
      html += `
        <div class="eda-stat-card">
          <div class="eda-stat-value">${stats.total_roads.toLocaleString()}</div>
          <div class="eda-stat-label">Total Roads</div>
        </div>
      `;
    }

    if (stats.total_nodes) {
      html += `
        <div class="eda-stat-card">
          <div class="eda-stat-value">${stats.total_nodes.toLocaleString()}</div>
          <div class="eda-stat-label">Total Nodes</div>
        </div>
      `;
    }

    if (stats.blocked_roads !== undefined) {
      html += `
        <div class="eda-stat-card">
          <div class="eda-stat-value">${stats.blocked_roads}</div>
          <div class="eda-stat-label">Blocked Roads</div>
        </div>
      `;
    }

    if (stats.avg_distance) {
      html += `
        <div class="eda-stat-card">
          <div class="eda-stat-value">${Math.round(stats.avg_distance)}m</div>
          <div class="eda-stat-label">Avg Distance</div>
        </div>
      `;
    }

    container.innerHTML = html;
  }

  function displayVisualizations(visualizations, container) {
      let html = '';

      const vizOrder = [
          { key: 'speed_limit', title: 'Speed Limit Distribution' },
          { key: 'blocked_edges', title: 'Blocked Roads Distribution' },
          { key: 'dead_ends', title: 'Dead End Distribution' },
          { key: 'road_direction', title: 'Road Direction Distribution' },
          { key: 'distance', title: 'Distance Distribution' },
          { key: 'duration', title: 'Duration Distribution' }
      ];

      vizOrder.forEach(viz => {
          if (visualizations[viz.key]) {
              html += `
                  <div class="eda-viz-card">
                      <div class="eda-viz-title">${viz.title}</div>
                      <img src="data:image/png;base64,${visualizations[viz.key]}" 
                          alt="${viz.title}" 
                          class="eda-viz-image" />
                  </div>
              `;
          }
      });

      container.innerHTML = html;
  }

  function showAlgorithmMetrics() {
    document.getElementById('algorithm-metrics-section').classList.remove('hidden');
    loadAlgorithmMetrics();
  }

  function hideAlgorithmMetrics() {
    document.getElementById('algorithm-metrics-section').classList.add('hidden');
  }

  async function loadAlgorithmMetrics() {
    const loadingElement = document.getElementById('metrics-loading');
    const errorElement = document.getElementById('metrics-error');
    const visualizationsElement = document.getElementById('metrics-visualizations');
    const statisticsElement = document.getElementById('metrics-statistics');
    
    loadingElement.classList.remove('hidden');
    errorElement.classList.add('hidden');
    visualizationsElement.innerHTML = '';
    statisticsElement.innerHTML = '';

    try {
      const startNode = document.getElementById('start_node').value.trim();
      const endNode = document.getElementById('end_node').value.trim();
      
      if (!startNode || !endNode) {
        throw new Error('Please set start and end nodes first');
      }

      const blockedEdgesArray = Array.from(blockedEdges).map(edge => {
        try { return JSON.parse(edge); } catch (e) { return null; }
      }).filter(edge => edge !== null);

      const disasterEdgesArray = Array.from(disasterEdges).map(edge => {
        try { return JSON.parse(edge); } catch (e) { return null; }
      }).filter(edge => edge !== null);

      const requestData = {
        start_node: startNode,
        end_node: endNode,
        blocked_edges: blockedEdgesArray,
        disaster_edges: disasterEdgesArray
      };

      const response = await fetch('/get_algorithm_metrics', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestData)
      });

      const data = await response.json();

      if (!data.success) {
        throw new Error(data.error || 'Failed to load algorithm metrics');
      }

      loadingElement.classList.add('hidden');

      if (data.scalability_metrics) {
        displayMetricsStatistics(data.scalability_metrics, statisticsElement);
      }

      if (data.visualizations) {
          displayMetricsVisualizations(data.visualizations, visualizationsElement);
        }

      } catch (error) {
        console.error('Error loading algorithm metrics:', error);
        loadingElement.classList.add('hidden');
        errorElement.classList.remove('hidden');
        document.getElementById('metrics-error-message').textContent = error.message;
      }
    }

    function displayMetricsStatistics(metrics, container) {
      let html = '';

      if (metrics.computational_efficiency) {
        const eff = metrics.computational_efficiency;
        html += `
          <div class="eda-stat-card" style="border-left-color: #dc2626;">
            <div class="eda-stat-value">${eff.avg_execution_time.toFixed(4)}s</div>
            <div class="eda-stat-label">Avg Execution Time</div>
          </div>
        `;
      }

      if (metrics.computational_efficiency) {
        const eff = metrics.computational_efficiency;
        html += `
          <div class="eda-stat-card" style="border-left-color: #059669;">
            <div class="eda-stat-value">${eff.avg_path_cost.toFixed(2)}</div>
            <div class="eda-stat-label">Avg Path Cost</div>
          </div>
        `;
      }

      if (metrics.adaptability) {
        const adapt = metrics.adaptability;
        html += `
          <div class="eda-stat-card" style="border-left-color: #7c3aed;">
            <div class="eda-stat-value">${(adapt.success_rate * 100).toFixed(1)}%</div>
            <div class="eda-stat-label">Success Rate</div>
          </div>
        `;
      }

      container.innerHTML = html;
    }

    function displayMetricsVisualizations(visualizations, container) {
        let html = '';

        if (visualizations.algorithm_comparison) {
            html += `
                <div class="mb-6">
                    <h4 class="font-semibold text-lg mb-3">Algorithm Performance Metrics</h4>
                    <div class="bg-white p-4 rounded-lg shadow-sm border">
                        <img src="data:image/png;base64,${visualizations.algorithm_comparison}" 
                            alt="Algorithm Performance Metrics" 
                            class="w-full h-auto rounded" />
                    </div>
                </div>
            `;
        }

        container.innerHTML = html;
    }

  function toggleAlgorithm(algorithm) {
    if (currentSelectedAlgorithm === algorithm) {
      algorithm = null;
    }
    
    currentSelectedAlgorithm = algorithm;
    
    document.querySelectorAll('#algorithm-legend .legend-item').forEach(item => {
      item.classList.remove('active');
    });
    
    if (algorithm) {
      document.getElementById(`legend-${algorithm}`).classList.add('active');
    }
    
    updateAlgorithmDisplay();
  }

  function updateAlgorithmDisplay() {
    for (const algo in pathLayers) {
      map.removeLayer(pathLayers[algo]);
    }
    pathLayers = {};
    
    clearRaceMarkers();
    
    if (currentSelectedAlgorithm && allAlgorithmResults[currentSelectedAlgorithm]) {
      const algo = currentSelectedAlgorithm;
      const result = allAlgorithmResults[algo];
      
      if (result.path && result.path.length > 0) {
        const latLngs = pathToLatLngs(result.path);
        if (latLngs.length > 1) {
          pathLayers[algo] = L.polyline(latLngs, {
            color: algorithmColors[algo],
            weight: 4,
            opacity: 0.7,
            dashArray: algo === 'Ant Colony' ? '5, 5' : null,
            className: 'path-line'
          }).addTo(map).bindPopup(`${algo} Path`);
        }
      }
      
      updateSingleAlgorithmResults(algo, result);
    } else {
      for (const algo in allAlgorithmResults) {
        const result = allAlgorithmResults[algo];
        
        if (result.path && result.path.length > 0) {
          const latLngs = pathToLatLngs(result.path);
          if (latLngs.length > 1) {
            pathLayers[algo] = L.polyline(latLngs, {
              color: algorithmColors[algo],
              weight: 4,
              opacity: 0.7,
              dashArray: algo === 'Ant Colony' ? '5, 5' : null,
              className: 'path-line'
            }).addTo(map).bindPopup(`${algo} Path`);
          }
        }
      }
      
      updateAllAlgorithmResults();
    }
  }

  function updateSingleAlgorithmResults(algo, result) {
    const resultsDiv = document.getElementById("results");
    
    let content = `
      <div class="mb-4">
        <h4 class="font-semibold text-lg mb-2">${algo} Algorithm Results</h4>
        <div class="bg-white p-4 rounded-lg shadow-sm border">
          <div class="grid grid-cols-2 gap-4">
            <div>
              <p class="text-sm text-gray-600">Path Found:</p>
              <p class="font-semibold">${result.path_found ? '‚úÖ Yes' : '‚ùå No'}</p>
            </div>
            <div>
              <p class="text-sm text-gray-600">Execution Time:</p>
              <p class="font-semibold">${result.execution_time > 0 ? result.execution_time.toFixed(4) + 's' : 'N/A'}</p>
            </div>
            <div>
              <p class="text-sm text-gray-600">Path Cost:</p>
              <p class="font-semibold">${result.cost > 0 ? result.cost.toFixed(2) : 'N/A'}</p>
            </div>
            <div>
              <p class="text-sm text-gray-600">Path Length:</p>
              <p class="font-semibold">${result.path_length} nodes</p>
            </div>
            <div>
              <p class="text-sm text-gray-600">Travel Time:</p>
              <p class="font-semibold">${result.travel_time > 0 ? result.travel_time.toFixed(2) + ' min' : 'N/A'}</p>
            </div>
          </div>
          ${result.path_found ? `
          <div class="mt-4">
            <p class="text-sm text-gray-600 mb-2">Path Preview:</p>
            <div class="text-xs bg-gray-100 p-2 rounded max-h-32 overflow-y-auto">
              ${result.path.slice(0, 10).join(' ‚Üí ')}${result.path.length > 10 ? ' ‚Üí ...' : ''}
            </div>
          </div>
          ` : ''}
        </div>
      </div>
      <div class="text-center">
        <button onclick="toggleAlgorithm(null)" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
          Show All Algorithms
        </button>
      </div>
    `;
    
    resultsDiv.innerHTML = content;
  }

  function updateAllAlgorithmResults() {
    const resultsDiv = document.getElementById("results");
    
    if (Object.keys(allAlgorithmResults).length === 0) {
      resultsDiv.innerHTML = `
        <div class="text-center text-gray-500 my-10">
          Set your blocked roads and click "Start Race" to begin
        </div>`;
      return;
    }
    
    let table = `
      <div class="mb-4">
        <h4 class="font-semibold text-lg mb-2">All Algorithm Results</h4>
        <table class="results-table">
          <thead>
            <tr>
              <th>Algorithm</th>
              <th>Time</th>
              <th>Cost</th>
              <th>Nodes</th>
              <th>Travel Time</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody>`;
    
    const sortedAlgorithms = Object.keys(allAlgorithmResults).sort((a, b) => {
      const costA = allAlgorithmResults[a].cost;
      const costB = allAlgorithmResults[b].cost;
      
      if (costA <= 0 && costB <= 0) return 0;
      if (costA <= 0) return 1;
      if (costB <= 0) return -1;
      
      return costA - costB;
    });
    
    sortedAlgorithms.forEach((algo, index) => {
      const data = allAlgorithmResults[algo];
      const isBest = index === 0 && data.cost > 0;
      
      table += `
        <tr>
          <td class="font-semibold" style="color: ${algorithmColors[algo]}">
            ${algo}${isBest ? ' ü•á' : ''}
          </td>
          <td class="font-mono">${data.execution_time > 0 ? data.execution_time.toFixed(4) + 's' : 'DNF'}</td>
          <td class="font-mono">${data.cost > 0 ? data.cost.toFixed(2) : 'N/A'}</td>
          <td>${data.path_length}</td>
          <td class="font-mono">${data.travel_time > 0 ? data.travel_time.toFixed(2) + ' min' : 'N/A'}</td>
          <td>${data.path_found ? '‚úÖ' : '‚ùå'}</td>
        </tr>`;
    });
    
    table += `
          </tbody>
        </table>
        <p class="text-xs text-gray-500 mt-2">ü•á = Best (Lowest Cost) | Click on algorithm names in the legend to view individual results</p>
      </div>`;
    
    let blockedRoadsList = '<div class="w-full text-sm"><h4 class="font-semibold text-gray-800 mb-2">Blocked Roads:</h4>';
    if (blockedEdges.size > 0) {
      Array.from(blockedEdges).forEach(edge => {
        try {
          const road = JSON.parse(edge);
          blockedRoadsList += `<div class="text-sm text-red-600 py-1">${road.start_node} ‚Üí ${road.end_node}</div>`;
        } catch (e) {
          console.error("Error parsing edge:", edge);
        }
      });
    } else {
      blockedRoadsList += '<div class="text-sm text-gray-500 py-1">No roads were blocked</div>';
    }
    blockedRoadsList += '</div>';
    
    resultsDiv.innerHTML = table + blockedRoadsList;
  }

  function validateCoordinate(coordStr) {
    const regex = /^\(-?\d+\.\d+,\s*-?\d+\.\d+\)$/;
    if (!regex.test(coordStr)) {
      return null;
    }
    return allRoads.some(road => 
      road.start_node === coordStr || road.end_node === coordStr
    ) ? coordStr : null;
  }

  function parseCoordinateInput(coordStr) {
    coordStr = coordStr.trim();
    
    let validated = validateCoordinate(coordStr);
    if (validated) return validated;
    
    const numbers = coordStr.match(/-?\d+\.\d+/g);
    if (numbers && numbers.length === 2) {
      const formatted = `(${numbers[0]}, ${numbers[1]})`;
      validated = validateCoordinate(formatted);
      if (validated) return validated;
    }
    
    return null;
  }

  function pathToLatLngs(path) {
    return path.map(node => {
      const coords = node.match(/-?\d+\.\d+/g);
      return coords ? L.latLng(parseFloat(coords[0]), parseFloat(coords[1])) : null;
    }).filter(coord => coord !== null);
  }

  function clearPaths() {
    for (const algo in pathLayers) {
      map.removeLayer(pathLayers[algo]);
    }
    pathLayers = {};
    if (startMarker) map.removeLayer(startMarker);
    if (endMarker) map.removeLayer(endMarker);
    clearRaceMarkers();
  }

  function clearRaceMarkers() {
    for (const algo in raceMarkers) {
      map.removeLayer(raceMarkers[algo]);
    }
    raceMarkers = {};
  }

  function clearRoads() {
    roadLayers.forEach(layer => map.removeLayer(layer.layer));
    roadLayers = [];
  }

  async function loadRoadData() {
    try {
      const response = await fetch('/get_road_data');
      allRoads = await response.json();
      plotRoads(allRoads);
    } catch (error) {
      console.error('Error loading road data:', error);
      document.getElementById('results').innerHTML = `
        <div class="text-center text-red-500 my-10">
          <p class="font-semibold">Error loading road data</p>
          <p class="text-sm">Please check if the server is running and the data file exists</p>
        </div>`;
    }
  }

  function plotRoads(roads) {
      clearRoads();
      
      roads.forEach(road => {
          const startCoords = road.start_node.match(/-?\d+\.\d+/g);
          const endCoords = road.end_node.match(/-?\d+\.\d+/g);
          
          if (startCoords && endCoords) {
              const forwardKey = `${road.start_node.trim()},${road.end_node.trim()}`;
              const reverseKey = `${road.end_node.trim()},${road.start_node.trim()}`;
              
              const isManuallyBlocked = Array.from(blockedEdges).some(storedEdge => {
                  try {
                      const parsedEdge = JSON.parse(storedEdge);
                      return (parsedEdge.start_node === road.start_node.trim() && 
                              parsedEdge.end_node === road.end_node.trim()) ||
                            (parsedEdge.start_node === road.end_node.trim() && 
                              parsedEdge.end_node === road.start_node.trim());
                  } catch (e) {
                      return false;
                  }
              });
              
              let disasterEffect = null;
              Array.from(disasterEdges).forEach(storedEdge => {
                  try {
                      const parsedEdge = JSON.parse(storedEdge);
                      if ((parsedEdge.start_node === road.start_node.trim() && 
                          parsedEdge.end_node === road.end_node.trim()) ||
                          (parsedEdge.start_node === road.end_node.trim() && 
                          parsedEdge.end_node === road.start_node.trim())) {
                          disasterEffect = parsedEdge;
                      }
                  } catch (e) {
                      console.error("Error parsing disaster edge:", e);
                  }
              });
              
              let roadColor = '#888888';
              let roadWeight = 2;
              let roadClassName = 'road-line';
              let roadOpacity = 0.7;
              
              if (isManuallyBlocked) {
                  roadColor = '#dc2626';
                  roadWeight = 4;
                  roadClassName = 'road-line blocked';
              } else if (disasterEffect) {
                  if (disasterEffect.is_end_node_access) {
                    roadColor = disasterColors['end_node_access'];
                    roadWeight = 4;
                  } else {
                    roadColor = disasterColors[disasterEffect.effect_type] || '#888888';
                    roadWeight = disasterEffect.completely_blocked ? 4 : 3;
                  }
                  roadClassName = 'road-line';
                  roadOpacity = 0.9;
              }
              
              const line = L.polyline([
                  [parseFloat(startCoords[0]), parseFloat(startCoords[1])],
                  [parseFloat(endCoords[0]), parseFloat(endCoords[1])]
              ], {
                  color: roadColor,
                  weight: roadWeight,
                  opacity: roadOpacity,
                  className: roadClassName
              }).addTo(map);

              line.on('click', function(e) {
                  handleRoadBlocking({
                      start_node: road.start_node,
                      end_node: road.end_node,
                      layer: line
                  });
              });
              
              if (disasterEffect) {
                  let popupContent = `Road: ${road.start_node} ‚Üí ${road.end_node}<br>`;
                  popupContent += `Disaster: ${disasterEffect.effect_type}<br>`;
                  if (disasterEffect.is_end_node_access) {
                      popupContent += 'Status: End Node Access Route<br>';
                      popupContent += `Delay: ${Math.round(disasterEffect.delay_seconds / 60)} minutes`;
                  } else if (disasterEffect.completely_blocked) {
                      popupContent += 'Status: Completely Blocked';
                  } else {
                      popupContent += `Delay: ${Math.round(disasterEffect.delay_seconds / 60)} minutes`;
                  }
                  line.bindPopup(popupContent);
              } else {
                  line.bindPopup(`Road: ${road.start_node} ‚Üí ${road.end_node}`);
              }
              
              roadLayers.push({
                  start: road.start_node,
                  end: road.end_node,
                  layer: line,
                  isBlocked: isManuallyBlocked,
                  disasterEffect: disasterEffect
              });
          }
      });
      updateBlockedCount();
  }

  function handleRoadBlocking(road) {
      if (!isBlockingMode) return;

      const edge = {
          start_node: road.start_node.trim(),
          end_node: road.end_node.trim()
      };
      
      const edgeKey = JSON.stringify(edge);
      const reverseEdgeKey = JSON.stringify({
          start_node: edge.end_node,
          end_node: edge.start_node
      });

      let isAlreadyBlocked = false;
      const edgesToRemove = [];
      
      blockedEdges.forEach(storedEdge => {
          const parsedEdge = JSON.parse(storedEdge);
          if ((parsedEdge.start_node === edge.start_node && 
              parsedEdge.end_node === edge.end_node) ||
              (parsedEdge.start_node === edge.end_node && 
              parsedEdge.end_node === edge.start_node)) {
              isAlreadyBlocked = true;
              edgesToRemove.push(storedEdge);
          }
      });

      if (isAlreadyBlocked) {
          edgesToRemove.forEach(e => blockedEdges.delete(e));
      } else {
          if (blockedEdges.size >= MAX_BLOCKED) {
              alert(`Maximum ${MAX_BLOCKED} blocked roads allowed`);
              return;
          }
          blockedEdges.add(edgeKey);
      }

      updateBlockedCount();
      plotRoads(allRoads);
  }

  function updateBlockedCount() {
    document.getElementById('blocked-count').textContent = blockedEdges.size;
  }

  function updateRaceState(state) {
    raceState = state;
    const stateElement = document.getElementById('race-state');
    stateElement.textContent = state.replace('_', ' ');
    
    stateElement.className = 'px-3 py-1 rounded-full text-sm font-medium transition-colors duration-300';
    
    switch(state) {
      case 'not_started':
        stateElement.classList.add('bg-gray-200', 'text-gray-800');
        break;
      case 'in_progress':
        stateElement.classList.add('bg-yellow-200', 'text-yellow-800');
        break;
      case 'finished':
        stateElement.classList.add('bg-green-200', 'text-green-800');
        break;
      default:
        stateElement.classList.add('bg-gray-200', 'text-gray-800');
    }
  }

  async function simulateDisaster(disasterType) {
    try {
      let requestData = {
        disaster_type: disasterType
      };
      
      if (disasterType === 'fire') {
        document.getElementById('fire-origin-container').classList.remove('hidden');
        
        const fireOriginInput = document.getElementById('fire_origin').value.trim();
        if (!fireOriginInput) {
          alert('Please provide a fire origin node for fire disaster simulation');
          return;
        }
        
        const fireOrigin = parseCoordinateInput(fireOriginInput);
        if (!fireOrigin) {
          alert('Please provide a valid fire origin node coordinate');
          return;
        }
        
        const endNodeInput = document.getElementById('end_node').value.trim();
        const endNode = parseCoordinateInput(endNodeInput);
        
        requestData.origin_node = fireOrigin;
        if (endNode) {
          requestData.end_node = endNode;
        }
        
        const disasterInfoDiv = document.getElementById('disaster-info');
        let infoContent = `
          <div class="disaster-info fire">
            <h4 class="font-semibold">FIRE DISASTER - CONTAINMENT ACTIVE</h4>
            <div class="text-sm mt-1">
              <p>üî• Fire containment protocol activated</p>
              <p>üö´ Limited to 2-3 blocked edges maximum</p>
              ${endNode && fireOrigin === endNode ? 
                '<p class="text-green-600 font-semibold">üéØ End node is fire origin - Will be reachable with 1-2 min delay</p>' : 
                '<p>üõ°Ô∏è Prevents uncontrolled spread</p>'
              }
              <p>üìç Origin: ${fireOrigin}</p>
            </div>
          </div>
        `;
        disasterInfoDiv.innerHTML = infoContent;
        disasterInfoDiv.classList.remove('hidden');
        
      } else {
        document.getElementById('fire-origin-container').classList.add('hidden');
      }
      
      const response = await fetch('/simulate_disaster', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestData)
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}`);
      }
      
      const data = await response.json();
      
      currentDisaster = data.disaster_info;
      
      disasterEdges.clear();
      
      data.affected_edges.forEach(edge => {
        disasterEdges.add(JSON.stringify(edge));
      });
      
      if (disasterType === 'fire') {
        updateFireDisasterInfo(data.disaster_info);
      } else {
        updateDisasterInfo(data.disaster_info);
      }
      
      plotRoads(allRoads);
      
    } catch (error) {
      console.error('Error simulating disaster:', error);
      alert('Error simulating disaster: ' + error.message);
    }
  }

  function updateFireDisasterInfo(disasterInfo) {
    const disasterInfoDiv = document.getElementById('disaster-info');
    
    if (!disasterInfo) {
      disasterInfoDiv.classList.add('hidden');
      return;
    }
    
    const endNodeInput = document.getElementById('end_node').value.trim();
    const endNode = parseCoordinateInput(endNodeInput);
    const isEndNodeFireOrigin = disasterInfo.origin_node === endNode;
    
    let infoContent = `
      <div class="disaster-info fire">
        <h4 class="font-semibold">üî• FIRE DISASTER - CONTAINED</h4>
        <div class="text-sm mt-1">
          <p class="font-semibold text-green-600">‚úÖ Fire successfully contained</p>
          <p>Blocked Edges: ${disasterInfo.blocked_edges} (Limited to prevent spread)</p>
          ${disasterInfo.end_node_access_edges > 0 ? 
            `<p class="text-blue-600 font-semibold">üéØ End node access edges: ${disasterInfo.end_node_access_edges} (1-2 min delay)</p>` : 
            ''
          }
          <p class="text-xs text-gray-500 mt-2">Containment Protocol: Limited to 2-3 blocked edges maximum to prevent uncontrolled spread</p>
          ${disasterInfo.origin_node ? `<p>Origin: ${disasterInfo.origin_node}</p>` : ''}
          ${isEndNodeFireOrigin ? 
            '<p class="text-green-600 font-semibold mt-2">‚úÖ End node will be reachable with additional delay</p>' : 
            ''
          }
        </div>
      </div>
    `;
    
    disasterInfoDiv.innerHTML = infoContent;
    disasterInfoDiv.classList.remove('hidden');
  }

  function updateDisasterInfo(disasterInfo) {
    const disasterInfoDiv = document.getElementById('disaster-info');
    
    if (!disasterInfo) {
      disasterInfoDiv.classList.add('hidden');
      return;
    }
    
    let infoContent = `
      <div class="disaster-info ${disasterInfo.type}">
        <h4 class="font-semibold">${disasterInfo.type.toUpperCase()} Disaster</h4>
        <div class="text-sm mt-1">
          <p>Blocked Edges: ${disasterInfo.blocked_edges}</p>
          ${disasterInfo.origin_node ? `<p>Origin: ${disasterInfo.origin_node}</p>` : ''}
        </div>
      </div>
    `;
    
    disasterInfoDiv.innerHTML = infoContent;
    disasterInfoDiv.classList.remove('hidden');
  }

  function clearDisaster() {
    disasterEdges.clear();
    currentDisaster = null;
    document.getElementById('disaster-info').classList.add('hidden');
    document.getElementById('fire-origin-container').classList.add('hidden');
    plotRoads(allRoads);
  }

  async function startRace() {
    const startNodeInput = document.getElementById("start_node").value.trim();
    const endNodeInput = document.getElementById("end_node").value.trim();
    const resultsDiv = document.getElementById("results");

    const startNode = parseCoordinateInput(startNodeInput);
    const endNode = parseCoordinateInput(endNodeInput);
    
    if (!startNode || !endNode) {
      resultsDiv.innerHTML = `
        <div class="text-center text-red-500 my-10">
          <p class="font-semibold">Please provide valid start and end coordinates</p>
          <p class="text-sm">Example: Start node: (14.179543, 121.241683) , End node: (14.153306, 121.248118)</p>
        </div>`;
      return;
    }

    let isEndNodeFireOrigin = false;
    if (currentDisaster && currentDisaster.type === 'fire') {
      const fireOrigin = currentDisaster.origin_node;
      if (fireOrigin === endNode) {
        isEndNodeFireOrigin = true;
      }
    }

    const blockedEdgesArray = Array.from(blockedEdges).map(edge => {
        try {
            return JSON.parse(edge);
        } catch (e) {
            console.error("Error parsing edge:", edge);
            return null;
        }
    }).filter(edge => edge !== null);

    const disasterEdgesArray = Array.from(disasterEdges).map(edge => {
        try {
            return JSON.parse(edge);
        } catch (e) {
            console.error("Error parsing disaster edge:", edge);
            return null;
        }
    }).filter(edge => edge !== null);

    const requestData = {
      start_node: startNode,
      end_node: endNode,
      blocked_edges: blockedEdgesArray,
      disaster_edges: disasterEdgesArray
    };

    resultsDiv.innerHTML = `
      <div class="h-full flex items-center justify-center text-gray-500">
        <div class="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500 mr-3"></div>
        <span class="text-lg">Calculating race paths...</span>
        ${isEndNodeFireOrigin ? 
          '<div class="mt-2 text-sm text-blue-600">Note: End node is fire origin - paths will have additional delay</div>' : 
          ''
        }
      </div>`;
    clearPaths();
    updateRaceState('in_progress');

    try {
      const response = await fetch("/run_simulation", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestData)
      });

      if (!response.ok) {
        throw new Error(`Server returned ${response.status}`);
      }

      const data = await response.json();
      if (!data.results || !Array.isArray(data.results)) {
        throw new Error("Invalid server response format");
      }

      allAlgorithmResults = {};
      data.results.forEach(result => {
        allAlgorithmResults[result.algorithm] = result;
      });

      const startCoords = startNode.match(/-?\d+\.\d+/g);
      const endCoords = endNode.match(/-?\d+\.\d+/g);
      
      if (startCoords) {
        startMarker = L.marker([parseFloat(startCoords[0]), parseFloat(startCoords[1])], {
          icon: L.divIcon({className: 'start-icon', html: 'üü¢', iconSize: [20, 20]})
        }).addTo(map).bindPopup("Start Point");
      }
      
      if (endCoords) {
        const isFireOrigin = currentDisaster && currentDisaster.type === 'fire' && currentDisaster.origin_node === endNode;
        endMarker = L.marker([parseFloat(endCoords[0]), parseFloat(endCoords[1])], {
          icon: L.divIcon({
            className: 'end-icon', 
            html: isFireOrigin ? 'üî•' : 'üî¥',
            iconSize: [20, 20]
          })
        }).addTo(map).bindPopup(isFireOrigin ? "End Point (Fire Origin - Delayed Access)" : "End Point");
      }

      if (startCoords && endCoords) {
        map.fitBounds([
          [parseFloat(startCoords[0]), parseFloat(startCoords[1])],
          [parseFloat(endCoords[0]), parseFloat(endCoords[1])]
        ], {padding: [50, 50]});
      }

      raceData = {};
      let maxPathLength = 0;

      const allAlgorithms = ['Dijkstra', 'A*', 'Greedy BFS', 'Ant Colony'];
      allAlgorithms.forEach(algo => {
        const result = allAlgorithmResults[algo] || {
          algorithm: algo,
          path_found: false,
          path: [],
          execution_time: 0,
          cost: -1,
          path_length: 0,
          travel_time: 0
        };

        if (result.path_found && result.path) {
          const latLngs = pathToLatLngs(result.path);
          if (latLngs.length > 1) {
            raceData[algo] = {
              path: latLngs,
              color: algorithmColors[algo],
              currentIndex: 0,
              finished: false,
              finishTime: result.execution_time,
              cost: result.cost,
              pathLength: result.path_length,
              travelTime: result.travel_time
            };
            maxPathLength = Math.max(maxPathLength, result.path_length);
            
            const pathLayer = L.polyline(latLngs, {
              color: algorithmColors[algo],
              weight: 4,
              opacity: 0.7,
              dashArray: algo === 'Ant Colony' ? '5, 5' : null,
              className: 'path-line'
            }).addTo(map).bindPopup(`${algo} Path`);
            
            pathLayers[algo] = pathLayer;
          }
        } else {
          raceData[algo] = {
            path: [],
            color: algorithmColors[algo],
            currentIndex: 0,
            finished: true,
            finishTime: 0,
            cost: -1,
            pathLength: 0,
            travelTime: 0
          };
        }
      });

      let raceUI = '<div class="space-y-4">';
      
      if (isEndNodeFireOrigin) {
        raceUI += `
          <div class="bg-blue-100 border border-blue-400 text-blue-700 px-4 py-3 rounded mb-4">
            <strong>Fire Origin Destination:</strong> The end node is the fire origin. Paths will have 1-2 minute delays but remain reachable.
          </div>
        `;
      }
      
      allAlgorithms.forEach(algo => {
        const data = raceData[algo];
        raceUI += `
          <div class="race-algorithm" data-algo="${algo}">
            <div class="flex justify-between items-center">
              <div class="flex items-center">
                <div class="w-3 h-3 rounded-full mr-2" style="background-color: ${algorithmColors[algo]}"></div>
                <span class="font-semibold">${algo}</span>
              </div>
              <div class="race-position">${data.finished ? 'DNF' : '1st'}</div>
            </div>
            <div class="race-progress">
              <div class="race-progress-bar" style="width: ${data.finished ? 0 : 0}%; background-color: ${algorithmColors[algo]}"></div>
            </div>
            <div class="text-xs text-gray-500 mt-1">
              <span class="distance">${data.finished ? '0' : '0'}/${data.pathLength} nodes</span>
              <span class="speed float-right">0.00 nodes/s</span>
            </div>
          </div>`;
      });
      
      raceUI += '</div>';
      resultsDiv.innerHTML = raceUI;

      startRaceAnimation(raceData);

    } catch (error) {
      resultsDiv.innerHTML = `
        <div class="text-center text-red-500 my-10">
          <p class="font-semibold">Error: ${error.message}</p>
          <p class="text-sm">Please check your inputs and try again.</p>
        </div>`;
      console.error("Race error:", error);
      updateRaceState('not_started');
    }
  }

  function startRaceAnimation(raceData) {
    if (raceInterval) clearInterval(raceInterval);
    
    clearRaceMarkers();
    
    const algorithms = Object.keys(raceData);
    algorithms.forEach(algo => {
      if (raceData[algo].path.length > 0) {
        const firstPoint = raceData[algo].path[0];
        raceMarkers[algo] = L.marker(firstPoint, {
          icon: L.divIcon({
            className: 'race-marker',
            html: `<div style="background-color: ${raceData[algo].color}; width: 16px; height: 16px; border-radius: 50%; border: 2px solid white;"></div>`,
            iconSize: [20, 20]
          })
        }).addTo(map).bindPopup(`${algo} Current Position`);
      }
    });
    
    let startTime = Date.now();
    let positions = algorithms.map(() => 0);
    let finishedCount = 0;
    
    raceInterval = setInterval(() => {
      const currentTime = Date.now() - startTime;
      let allFinished = true;
      let maxProgress = 0;
      
      algorithms.forEach((algo, index) => {
        const data = raceData[algo];
        if (data.finished) {
          positions[index] = data.path.length;
          return;
        }
        
        allFinished = false;
        
        const targetProgress = Math.min(1, currentTime / (data.finishTime * 1000));
        const targetIndex = Math.floor(targetProgress * (data.path.length - 1));
        
        if (targetIndex > data.currentIndex) {
          data.currentIndex = targetIndex;
          const currentPoint = data.path[targetIndex];
          
          if (raceMarkers[algo]) {
            raceMarkers[algo].setLatLng(currentPoint);
          }
          
          const progressPercent = (targetIndex / (data.path.length - 1)) * 100;
          const algoElement = document.querySelector(`.race-algorithm[data-algo="${algo}"]`);
          if (algoElement) {
            algoElement.querySelector('.race-progress-bar').style.width = `${progressPercent}%`;
            algoElement.querySelector('.distance').textContent = `${targetIndex}/${data.pathLength} nodes`;
            
            const speed = targetIndex / (currentTime / 1000);
            algoElement.querySelector('.speed').textContent = `${speed.toFixed(2)} nodes/s`;
          }
          
          positions[index] = targetIndex;
          
          if (targetIndex >= data.path.length - 1) {
            data.finished = true;
            finishedCount++;
            
            if (raceMarkers[algo]) {
              raceMarkers[algo].setIcon(L.divIcon({
                className: 'race-marker',
                html: `<div style="background-color: ${data.color}; width: 16px; height: 16px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 0 4px ${data.color}44;"></div>`,
                iconSize: [20, 20]
              }));
            }
          }
        }
        
        maxProgress = Math.max(maxProgress, targetIndex);
      });
      
      if (!allFinished) {
        const algorithmProgress = algorithms.map((algo, index) => {
          const data = raceData[algo];
          return {
            algo: algo,
            progress: positions[index],
            cost: data.cost,
            finished: data.finished
          };
        });
        
        algorithmProgress.sort((a, b) => {
          if (a.finished && !b.finished) return -1;
          if (!a.finished && b.finished) return 1;
          
          if (a.cost > 0 && b.cost > 0) {
            if (a.cost !== b.cost) {
              return a.cost - b.cost;
            }
          }
          
          return b.progress - a.progress;
        });
        
        algorithmProgress.forEach((item, sortedIndex) => {
          const algo = item.algo;
          let positionText;
          
          if (sortedIndex === 0 && raceData[algo].finished) {
            positionText = 'ü•á Winner!';
          } else if (sortedIndex === 1 && raceData[algo].finished) {
            positionText = 'ü•à 2nd';
          } else if (sortedIndex === 2 && raceData[algo].finished) {
            positionText = 'ü•â 3rd';
          } else if (sortedIndex === 3 && raceData[algo].finished) {
            positionText = '4Ô∏è‚É£ 4th';
          } else {
            positionText = `${sortedIndex + 1}${getOrdinalSuffix(sortedIndex + 1)}`;
          }
          
          const algoElement = document.querySelector(`.race-algorithm[data-algo="${algo}"]`);
          if (algoElement) {
            const positionElement = algoElement.querySelector('.race-position');
            positionElement.textContent = positionText;
            
            if (sortedIndex === 0) {
              positionElement.className = 'race-position text-yellow-600';
            } else if (sortedIndex === 1) {
              positionElement.className = 'race-position text-gray-400';
            } else if (sortedIndex === 2) {
              positionElement.className = 'race-position text-amber-600';
            } else {
              positionElement.className = 'race-position';
            }
          }
        });
      }
      
      if (allFinished) {
        clearInterval(raceInterval);
        updateRaceState('finished');
        
        updateAllAlgorithmResults();
      }
    }, 50);
  }

  function getOrdinalSuffix(num) {
    const j = num % 10, k = num % 100;
    if (j === 1 && k !== 11) return 'st';
    if (j === 2 && k !== 12) return 'nd';
    if (j === 3 && k !== 13) return 'rd';
    return 'th';
  }

  function showFinalResults(raceData) {
    const resultsDiv = document.getElementById("results");
    
    const endNodeInput = document.getElementById('end_node').value.trim();
    const endNode = parseCoordinateInput(endNodeInput);
    const isEndNodeFireOrigin = currentDisaster && currentDisaster.type === 'fire' && currentDisaster.origin_node === endNode;
    
    let table = `
      <div class="mb-4">
        ${isEndNodeFireOrigin ? `
          <div class="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded mb-4">
            <strong>Fire Origin Destination:</strong> The end node was the fire origin. Paths successfully reached the destination with additional delays.
          </div>
        ` : ''}
        <h4 class="font-semibold text-lg mb-2">Final Results</h4>
        <table class="results-table">
          <thead>
            <tr>
              <th>Position</th>
              <th>Algorithm</th>
              <th>Time</th>
              <th>Cost</th>
              <th>Nodes</th>
            </tr>
          </thead>
          <tbody>`;
    
    const sortedAlgorithms = Object.keys(raceData).sort((a, b) => {
      const costA = raceData[a].cost;
      const costB = raceData[b].cost;
      
      if (costA <= 0 && costB <= 0) return 0;
      if (costA <= 0) return 1;
      if (costB <= 0) return -1;
      
      return costA - costB;
    });
    
    const medals = ['ü•á', 'ü•à', 'ü•â', '4Ô∏è‚É£'];
    
    sortedAlgorithms.forEach((algo, index) => {
      const data = raceData[algo];
      const position = index + 1;
      const medal = position <= 4 ? medals[position - 1] : `${position}${getOrdinalSuffix(position)}`;
      
      table += `
        <tr>
          <td class="font-semibold">${medal}</td>
          <td class="font-semibold" style="color: ${data.color}">${algo}</td>
          <td class="font-mono">${data.finishTime > 0 ? data.finishTime.toFixed(4) + 's' : 'DNF'}</td>
          <td class="font-mono">${data.cost > 0 ? data.cost.toFixed(2) : 'N/A'}</td>
          <td>${data.pathLength}</td>
        </tr>`;
    });
    
    const allAlgorithms = ['Dijkstra', 'A*', 'Greedy BFS', 'Ant Colony'];
    const missingAlgorithms = allAlgorithms.filter(algo => !sortedAlgorithms.includes(algo));
    
    missingAlgorithms.forEach((algo, index) => {
      const position = sortedAlgorithms.length + index + 1;
      table += `
        <tr>
          <td class="font-semibold">${position}${getOrdinalSuffix(position)}</td>
          <td class="font-semibold" style="color: ${algorithmColors[algo]}">${algo}</td>
          <td class="font-mono text-gray-400">DNF</td>
          <td class="font-mono text-gray-400">N/A</td>
          <td class="text-gray-400">0</td>
        </tr>`;
    });
    
    table += `
          </tbody>
        </table>
        <p class="text-xs text-gray-500 mt-2">ü•á = Best (Lowest Cost)</p>
      </div>`;
    
    let blockedRoadsList = '<div class="w-full text-sm"><h4 class="font-semibold text-gray-800 mb-2">Blocked Roads:</h4>';
    if (blockedEdges.size > 0) {
      Array.from(blockedEdges).forEach(edge => {
        try {
          const road = JSON.parse(edge);
          blockedRoadsList += `<div class="text-sm text-red-600 py-1">${road.start_node} ‚Üí ${road.end_node}</div>`;
        } catch (e) {
          console.error("Error parsing edge:", edge);
        }
      });
    } else {
      blockedRoadsList += '<div class="text-sm text-gray-500 py-1">No roads were blocked</div>';
    }
    blockedRoadsList += '</div>';
    
    resultsDiv.innerHTML = table + blockedRoadsList;
  }

  function resetAll() {
    if (raceInterval) clearInterval(raceInterval);
    updateRaceState('not_started');
    
    blockedEdges.clear();
    updateBlockedCount();
    
    clearDisaster();
    
    currentSelectedAlgorithm = null;
    document.querySelectorAll('#algorithm-legend .legend-item').forEach(item => {
      item.classList.remove('active');
    });
    
    roadLayers.forEach(road => {
      road.layer.setStyle({
        color: '#888888',
        weight: 2,
        className: 'road-line'
      });
    });
    
    clearPaths();
    
    document.getElementById('results').innerHTML = `
      <div class="text-center text-gray-500 my-10">
        <p class="mb-4">Set your start and end nodes, configure disasters, and click "Start Race" to begin</p>
        <div class="text-sm text-gray-400">
          <p>‚Ä¢ Use Block Mode to manually block roads</p>
          <p>‚Ä¢ Fire disasters are limited to 2-3 blocked edges for containment</p>
          <p>‚Ä¢ End nodes remain reachable with 1-2 minute delays in fire disasters</p>
          <p>‚Ä¢ Compare performance across different pathfinding algorithms</p>
        </div>
      </div>`;
    
    document.getElementById('blocking-toggle').checked = true;
    isBlockingMode = true;
  }

  window.onload = function() {
    initMap();
    initAlgorithmLegend();
  };
  </script>
</body>
</html>
